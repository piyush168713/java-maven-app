// l-154

// complete CI/CD pipeline with EKS and ECR

// Deploy docker image to EKS k8s cluster using AWS ECR Docker Repo 

// AWS ECR docker repo - 399434923446.dkr.ecr.ap-south-1.amazonaws.com/java-maven-app

// file used = /kubernetes/deployment1.yaml & /kubernetes/service1.yaml

pipeline {
    agent any
    tools {
        maven 'maven-3.9'
    }

    environment{
        AWS_DOCKER_REPO_SERVER = '399434923446.dkr.ecr.ap-south-1.amazonaws.com'
        AWS_DOCKER_REPO = '${AWS_DOCKER_REPO_SERVER}/java-maven-app'
    }

    stages {
        stage("increment version"){
            steps{
                script {
                    echo 'increment app version...'
                    sh 'mvn build-helper:parse-version versions:set \
                        -DnewVersion=\\\${parsedVersion.majorVersion}.\\\${parsedVersion.minorVersion}.\\\${parsedVersion.nextIncrementalVersion} \
                        versions:commit'
                    def matcher = readFile('pom.xml') =~ '<version>(.+)</version>'
                    def version = matcher[0][1]
                    env.IMAGE_NAME = "$version-$BUILD_NUMBER"
                }
            }
        }

        stage("build jar"){
            steps {
                script {
                    echo "building the application..."
                    sh 'mvn clean package'
                }
            }
        }
 
        // take creds from ecr-credentials which is placed in Jenkins Credentials store and use in below line codes
        // passing password as "echo $pass" (same as -> aws ecr get-login-password that is placed inside creds store)
        // these steps are for pushing image to repo
        // use k8s secrets file to store docker repo username and password for pulling image from repo
        stage("build image"){
            steps {
                script {
                    echo "building the docker image..."
                    withCredentials([usernamePassword(credentialsId: 'ecr-credentials', usernameVariable: 'USER', passwordVariable: 'PASS')]) {
                        sh "docker build -t ${AWS_DOCKER_REPO}:${IMAGE_NAME} ."
                        sh "echo $PASS | docker login -u $USER --password-stdin ${AWS_DOCKER_REPO_SERVER}"
                        sh "docker push ${AWS_DOCKER_REPO}:${IMAGE_NAME}"
                    }
                }
            }
        }

        // kubectl command executes which will use the config file that we created at default location, i.e. kubeconfig.yaml file. 
        // kubeconfig.yaml file provided inside the jenkins container so that kubectl knows that where to connect the server, on which url it find the cluster. 
        // with kubectl execution, aws iam authenticator also get executes and then it uses both access key and secret access key used for authenticating(connect) with AWS as well as authenticating with k8s cluster (ECR).
        // then you successfully logged in(authenticated) to AWS.

        // kubectl command executes which will use the config file that we created at default location, i.e. kubeconfig.yaml file. 
        // and inside that config file it is configured that iam authenticator needs to be used in order to authenticate with the AWS account
        // and when aws iam authenticator command get triggered in the background as a result it needs credentials to connect with the AWS account
        // so those two will be used (access key and secret access key) to authenticate that are set in env variable(Jenkinsfile10).

        // we'll use aws ecr registry secret (aws-registry-key)
        // when we execute this "kubectl apply" with the deployment yaml file and we set the new image name in deployment yaml file, kubernetes must be 
        // allow to fetch the new image from the private (AWS ECR) repository, so we need authentication with registry from inside k8s cluster.
        // we need to create Secret only once per namespace, we dont put secret in pipeline.
        // we'll create secret from our local machine when connected to eks cluster.
        // and put imagePullSecrets in deployment file with name of secret (aws-registry-key), everytime k8s check this config(deployment) file, it
        // see a private repo and image that have to fetch from there, it will needs the registry creds, so it will take from the secrets inorder to pull the image. 
        // now deploy it using a new image version into the k8s cluster. 
        stage('deploy') {
            environment {
               AWS_ACCESS_KEY_ID = credentials('jenkins_aws_access_key_id')
               AWS_SECRET_ACCESS_KEY = credentials('jenkins_aws_secret_access_key')
               APP_NAME = 'java-maven-app'
            }
            steps {
                script {
                   echo 'deploying docker image...'
                   sh 'envsubst < kubernetes/deployment1.yaml | kubectl apply -f -'
                   sh 'envsubst < kubernetes/service1.yaml | kubectl apply -f -'
                }
            }
        }


        stage('commit version update'){
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'gitlab-credentials', usernameVariable: 'USER', passwordVariable: 'PASS')]) {
                        // sh 'git config --global user.email "piyush@jenkins.com"'
                        // sh 'git config --global user.name "jenkins"'

                        // sh 'git status'
                        // sh 'git branch'
                        // sh 'git config --list'

                        sh "git remote set-url origin https://${USER}:${PASS}@gitlab.com/piyush168713/java-maven-app.git"
                        sh 'git add .'
                        sh 'git commit -m "ci: version bump"'
                        sh 'git push origin HEAD:jenkins-jobs -f'
                    }
                }
            }
        }
    }
}